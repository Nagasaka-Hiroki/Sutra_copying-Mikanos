# 疑問(第3章,第4章)
　README.mdに追記したが、そういうものと思ってある程度進めること。  
しかし、疑問を持つことは大切なのでメモ程度に書き込んでいく。
# 第3章
## osbook_day03aの前
### レジスタの話。
　みかん本の前に少しだけOS自作入門を読んでいた。その内容に近い感じの内容。しかし、CPUを保護モードにするためレジスタの値を変えるというのはすべてのCPUアーキテクチャで共通なのだろうか？OS自作入門では確かx86の話が前提だと思うし、みかん本では節の初めのほうでx86-64の話だとしている。もし、今後x86-64しか触らないのであればこの話は忘れていいかもしれないが、そんなことはない。そういうことはおそらくみかん本の参考文献[3]が役に立つと思う。  
> - [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)  

しかし、試しに  ```Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4```  を開いたが、約5000ページある。なので今はやめておこう。  
もし、CPUのアーキテクチャを意識しなければならないときはこれを読む必要がある。  

## osbook_day03a
### Loader.inf
　これはedk2固有のファイルなので、OS作りの本質でない（ほかのツールなら不要であるため）。そのためこのファイルの変更はそういうものととらえる。  
　ただ、謎は```git diff osbook_day02b osbook_day03a```と実行し前回との差分をとったが、変化していないところまで表示されるのはなぜだろう？私のコマンドが間違っているのだろうか？ひとまず目視で差分を取れたのでそれを書き込んでいく。

### EFI boot stub?
### EFI_FILE_INFO型？
　次のページに詳細があった。

### "\\\kernel.elf"の文字数
　ヌル文字を含めると13文字に見える。初めの'\\'はエスケープシーケンスの意味だろうか？

### file_info_buffer[file_info_size]はなぜOK?
　私がC言語を学習したときは、配列の要素数は変数はダメだったはず…。気になって独習Cを覗きに行くと、p.122にC11の仕様でVLA(variable length array)が使えるらしい。なので今回だとVLAが有効なのでOKだということだと思う。
　ネットでも検索してみたら以下の記事がヒットした。  
> - [【C99】可変長配列を試してみる](https://tyfkda.github.io/blog/2019/12/31/variable-length-array.html)  

この記事によればC99でVLAが使えるとのことですが、C99とかC11の後の数字は多分西暦の下二桁だとおもう（調べたらその通りだった。[C99とC11](https://www.cloverfield.co.jp/2016/06/24/c99%E3%81%A8c11/))  
　C言語のバージョンによってある程度違うと思うのでバージョンも少し気にしておきたい。(現状コンパイラのバージョンについて言及されていないので出てきたらしっかり確認したい。)

### ```UINT8 file_info_buffer[file_info_size];```?
　ファイル情報を保存する配列はなぜUINT8の配列で保存するのだろうか？単純に、GetInfo()の仕様でUINT8であるだけであればいいが…。今はそういうものとする。

### EFI_PHYSICAL_ADDRESS ？
### typedef void EntryPointType(void); ?
　この一文でちょっと焦った。これまでも、   
```
    typedef int (*FunctionPointer)(int);
```
みたいな、関数ポインタ型の宣言を見てきたので、当然  
```
    typedef void EntryPointType(void);
```
こっちもあるよねというのは理解できるが想像していなかった。  

以下に参考を貼る。  
> - [C言語のtypedefについて具体例を用いて分かりやすく解説](https://daeudaeu.com/c-typedef/)  
> - [Typedefの考え方](https://qiita.com/aminevsky/items/82ecce1d6d8b42d65533)  

特に2つ目が参考になった。やっぱりだが自分と同じ疑問を持っている人がいて少しほっとした。typedefの書き方の基本から逸脱しているが間違いではない。  

とりあえず、認識としては、引数がvoid、返り値もvoidの関数の型を宣言するといった型宣言という認識でいいと思う。
そういう風に考えると関数ポインタの方も理解しやすい。  
それにtypedefは型名のあだ名を作るのが役割だし、その認識で間違いないと思う。

## osbook_day03b
### for文のi++と++i
　以下のURLにきれいにまとめてくれていた。  
> - [i++と++iの違い](https://qiita.com/suuungwoo/items/e054fdcb5a4805bb226b)  

for文においては違いはない。なので好みの問題。

この節は説明が少なく、そういうものと割り切るものが多かったので、写経がメインだった。  
一通り写経したので次に進む。

## osbook_day03c
　そういうものという感じのもの以外は疑問はない。   
　基本的にはブートローダで関数プロトタイプ宣言と、GOPデータを引数で渡す（GOPを事前に取得する必要はあるが）。  
　カーネル側の引数も変えて、渡された配列にデータを書き込むと、色を塗れるという感じだった。  
　講義動画ではABIについて言及されていた。その話の概要は難しくないが詳細はかなり知識がないと読み解けない内容だと思ったので今は放置する。

## osbook_day03d
　osbook_day03dと第4章は講義動画ではosbook_day03cのおまけみたいな感じで流されてしまった。あまり重要ではないのだろうか？  
とりあえず写経はするが、そこまで時間を書けないように注意する。

追記->　メモを忘れていたので追ってメモする。
osbook_day03dは内容は難しくない。これまで書いてきたコードのエラーが発生しそうなところ（gBSのメンバ関数にアクセス、ファイル処理など）に対して、エラーが発生したらメッセージと共にCPUを待機状態にする処理をつけるだけだった。しかし、そのあとのポインタの話の方が重要だった気がする。この部分は前にも読んだし、OS自作入門のところでも確認したはずなので今回は飛ばす。しかし困ったらここに帰ってくること。

# 第4章
　前述の通り講義動画ではほとんど触れられず5章に進んでいった。しかしmakefileの書き方やC++の機能に関して言及している章なので、時間はかけられないがしっかり理解したい内容だと感じるところ。
## osbook_day04a
　この節はmakefileの説明についてだった。あまり重点的にするところでもないと思ったので、Makefileの書き方に困ったら戻ってくるくらいに思っておこうと思う。

　makeを実行せずにpushしていた。makeで動作確認とコードの修正をした。ちゃんとコンパイルできたので再pushする。  

## osbook_day04b
### PixelBitMaskとPixelBltOnly？
　調べたがブログなどは見つからなかった。なので調べるとすると仕様書になる。こちらは現状時間がかかるのでいったん保留。

### 8bitの色でOSを作ったあと、そのOS上でアプリの色は最大8bitになるのか？
　ハードウェアが24bitカラーをサポートしていなければ本質的に不可能であるが、そうでない場合一般的に色の表現で用いられる24bitカラーは使えるのか。その場合このOSの初期の段階で設定しなければ使えないのではないだろうか？後から使えるようにするのか、それとも24bitを8bitに強制的にデータを減らすのか？どういったようにしているのだろうか？  
　本の説明ではブートローダからカーネルに描画に必要な情報を渡している。カーネルがそれをブートローダやブートサービスを用いずに取得する方法はあるのだろうか？  
　いま考えるのは早軽かもしれないが、できれば自作OS上でWindowsのDirectXみたいなものを作って見たい（本来自作OSを始めたのはそういったグラフィック関係の知識やPCに関する知識を深めるためであるため）。なので、そういったものを作りたいと思ったとき、この問題をどうとらえれば解決できるだろうか？

### なぜ同じヘッダーファイルが別のディレクトリに存在する？
　保守性が悪くなるのになぜこんなことをするのだろうか？  
　結論：よく見たらシンボリックリンクでファイルの実態はkernelのディレクトリにあった。  
　シンボリックリンクなので作成コマンドは以下の手順のはず、  
    ```
        cd Sutra_copying-Mikanos
        cd MikanLoaderPkg
        ln -s ../kernel/frame_buffer_config.hpp ./
    ```
    そういえば、ln -s　の-sの意味を知らない。（[lnコマンドについて詳しくまとめました 【Linuxコマンド集】](https://eng-entrance.com/linux-command-ln#-s--symbolic)によればシンボリックリンクを作成するという意味らしい。)  

### Doxyfile?
　いきなり、本文中にもない（多分）ファイルが追加されている。

> -[Doxygenの使い方](https://www.hiroom2.com/2015/09/22/doxygen%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9/#:~:text=3%20Doxyfile,%E3%82%92%E8%A8%98%E8%BF%B0%E3%81%99%E3%82%8B%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A7%E3%81%99%E3%80%82)  

このページによれば、このファイルはソースコードからHTMLファイルを作るためのものらしい。なので関係ないファイルだと思う。  

### c++ 参照について
　参照の使い方があいまい。独習c++であまり読んでいなかったところなのでその都度調べていきたい。

### 構造体の使い方について
　参照型の使い方の問題だろうか？例えば次のコード  
```
    int WritePixel(const FrameBufferConfig& config, int x, int y, const PixelColor& c)
```
の　FrameBufferConfigとPixelColorは構造体である。通常構造体を引数として渡すときはtypedefであだ名をつけていない限り、  
```struct 構造体名```とするはずだが、この書き方はなんだろう？

### WritePixelとstruct PixelColorについて
　ブートローだで渡されているピクセルフォーマットは  
```
    PixelRedGreenBlueReserved8BitPerColor
    または、
    PixelBlueGreenRedReserved8BitPerColor
    のどちらか。
```
これらは8bitで色を表すことになっているはず。? 

読み直したら読み間違いだった。上記二つが8bitで色を表すのではなく、8bitしか使えない場合そうなるよという説明。  
実際、100ページの説明で、R,G,Bそれぞれ8bitづつ使えるとなっていた。なので問題ない。struct PixelColorの各色がUINT8であるのはそのため。

### ビルド
　忘れそうになったのでメモ。makeの前に環境変数を設定する。設定用のシェルスクリプトは```~/osbook/devenv/buildenv.sh```である。  
このスクリプトを、  
```
    source ~/osbook/devenv/buildenv.sh
```
で実行して環境変数を設定する。設定しなければインクルードパスがうまく通らないのでエラーが出る。

## osbook_day04c
### インターフェースと実装を分離する？
　具体的にどういったことを言っているのだろうか？

### コンストラクタの書き方
　コンストラクタの書き方で、宣言の後に : で区切って関数の内容を書くやり方があったはずだが、うまく思い出せない。  
なので下の書き方  
```
    PixelWriter(const FrameBufferConfig& config) : config_{config} {}
```
がどういう挙動をするかちゃんと説明できない。みかん本の説明を読むと、config_にconfigが代入されるとなっているがどうしてそうなるか説明できない。  
ここが読めないと前に進めないわけではないが、一応メモ。  
(加えてこれをどういったワードで調べたらいいかわからない。)

過去のブックマークを調べると出てきた。以下にURLを示す。  
> - [手を動かして さくさく理解する C++ クラス 入門](http://vivi.dyndns.org/tech/cpp/class-basic.html)  

この記事によれば、上記の書き方はメンバ変数の初期化にあたる。しかし疑問なのは ( ) ではなく { } を使用している点である。  
違いはあまり気にしなくてもいいのだろうか？  

### c++の話。
- noexcept 例外を送出する可能性がない関数　[https://cpprefjp.github.io/lang/cpp11/noexcept.html](https://cpprefjp.github.io/lang/cpp11/noexcept.html)  
- 配置newの書き方。  
    ```
        pixel_writer = new(pixel_writer_buf) RGBResv8BitPerColorWriter{frame_buffer_config};
    ```
    通常のnew演算子の引数はsizeだけだそうだ。なのでsizeのところは引数に指定しなくてもいいから、new演算しの引数は配列の先頭アドレスとすればいいのだろうか？そういう解釈をして理解するしか今は無理だと思う。また、今回も出たがこれまで私が ( ) として学んだところが { } になっている。なので用途によると思うがこの場合は同じと思ってもいいと思う。

### 前回のコードのスペルミス
　コンパイルエラーが出ないところでスペルのミスがあった。今回の分で修正しているが注意したい。

## osbook_day04d
### 本文中「カーネルの読み込み処理にバグがあります」について
　どうやったらバグだとわかる？

### どこで正しい大きさを計っている？
　これまでの方法ではバグがあるとわかっているとして、一時領域にカーネルを読み込むとき、読み込む大きさは前と同じ値を使っているように見える。  
どの段階で正しい大きさになっているのだろうか？仮に大きさが間違っているとしたら仮領域（```gBS->AllocatePool```)を実行した段階では正しい大きさのメモリ確保ができず、失敗するのではないのだろうか？

### 前回うまくいった理由
　前回までバグがあったのになぜうまくいったか。断定はできないが、メモリの確保にページ単位を使ったからだと推測される。ページ単位で確保したがゆえにある程度余分にメモリが確保される。それゆえに多少メモリサイズの計算が間違っていても問題なくリロードすることができたのだと推測される。  
　だったらこのままでよくない？と思われるかもしれないが、本書の説明でもあったように、グローバル変数が初期化されていないなどの原因によってファイルの実体がディスク上にある時とメモリ上にある時で大きさが変わってしまう。それゆえにきちんと正確に大きさを計れるようにならないと、今後もしページ数が変わる特別なケースに遭遇した場合厄介なエラーを含むプログラムになってしまう。そのため正しくメモリ上に配置された場合の大きさを計算できるようにならなければいけない。  
　というのが私の理解。

　進めていくとまた謎が増えた。エントリポイントのアドレス指定が、  
```
    UINT64 entry_addr = *(UINT64*)(kernel_first_addr + 24);
```
　となっている。  
　戻って読んだら意味があるみたい。前日に読んでいたので忘れていた。リンク時のアドレス指定が変わっても実行できるようにということだから、この変更は意味がちゃんとある。

### 構造体の大きさ？
　非常に基本的なことだが、ファイルをメモリにロードするところまではいいのだが、その先頭アドレスを構造体のポインタにキャストしたり、オフセットして別の構造体にキャストする操作があるが、その際には構造体の大きさ（厳密には構造体が持っている本来のメモリサイズ）を超えていないだろうか？ポインタにキャストしているため、ポインタが指し示すデータの解釈が変わるというのは理解できる。しかし構造体にキャストした場合にはメモリの大きさを考えなくてもいいのだろうか？独習Cでは結構気にしていた覚えがあるのだが、実際気にしなくてもいいのだろうか？それとも気にする必要があるのはポインタではなく、単純に変数として宣言した時に実際にメモリを確保する動作を含むときだけだろうか？幸い、現在は先にメモリを確保し、そのデータの解釈をポインタをキャストして変えているという流れだろうから、そのほうが自然だろうか？

## SetMem,CopyMem
　Printと同様にUEFI(or edk2)が提供する関数だと思って進める。

## オフセットファイルサイズ
　これは必ず先頭アドレスからのオフセット？

## ロードの認識
　今までなんとなくメモリ上にファイルを読み込むことをロードだと考えていたが、今回の節でファイルのロードセグメント情報をもとにメモリ上にデータを配置していくという認識に改めたほうがいいと思った。そうでないとなんとなく、感覚的に今回のプログラムを理解できない気がする。  
　ロードとはロードセグメント情報をもとにデータをメモリに配置すること。これを覚える。

## 4章終了
　最後のほうはほとんど画面の見た目が変わらないのに内容が意外と重厚だった。改めて自分はプログラム言語しか知らなかったんだと実感した。重要なのはこれを知ったうえでどのように自分でものづくりしていくかなので、可能であればそういった方向も少しずつ考えていきたい。